<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>areaDetector Pilatus driver</title>
</head>
<body>

<center>
<h1>areaDetector Pilatus driver</h1>

<h2> September 5, 2008</h2>
<h2> Mark Rivers</h2>
<h2> University of Chicago</h2>
</center>

<p>&nbsp;</p>

<h2>Table of Contents</h2>
  <ul>
    <li><a href="#Introduction">Introduction</a></li>
    <li><a href="#StandardNotes">Implementation of standard driver parameters</a></li>
    <li><a href="#Driver_parameters">Pilatus specific parameters</a></li>
    <li><a href="#Unsupported">Unsupported standard driver parameters</a></li>
    <li><a href="#Screenshots">Screenshots</a></li>
    <li><a href="#Configuring">Configuring</a></li>
    <li><a href="#Performance measurements">Performance measurements</a> </li>
    <li><a href="#Hardware notes">Hardware notes</a> </li>
    <li><a href="#Restrictions">Restrictions</a> </li>
  </ul>


<center><h2 id="Introduction">
                Introduction</h2></center>
                    
This is a driver for the Pilatus pixel array detectors
<a href="http://www.dectris.com">Dectris</a>.
It inherits from ADDriver and implements many of the parameters in ADStdDriverParams.h.
It also implements a number of parameters that are specific to the Pilatus detectors.
<p>
The interface to the detector is via a TCP/IP socket interface to the <b>camserver</b> server that Dectris provides.
The camserver program must be started before the areaDetector software is started, typically by running the
<b>camonly</b> script provided by Dectris.
</p>
<p>
The camserver program saves the data to disk as TIFF files.  The areaDetector software reads these disk files in
order to read the data, because camserver does not provide another mechanism to access the data.
</p>
<center><h2 id="StandardNotes">
                Implementation of standard driver parameters</h2></center>

<p>
The following table describes how the Pilatus driver implements some of the standard driver parameters.
</p>
<table style="text-align: left" cellspacing="2" cellpadding="2" border="1">
  <tbody>
  <tr>
    <td colspan="3", align="center"><b>Parameter Definitions in pilatusDetector.cpp and EPICS Record Definitions in pilatus.template</b></td>
  </tr>
  <tr>
    <th>Enum name</th>
    <th>EPICS record name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>ADTriggerMode</td>
    <td>$(P$(R)TriggerMode</td>
    <td>The driver redefines the choices for the ADTriggerMode parameter (record $(P)$(R)TriggerMode) from ADStdDriverParams.h.
        The choices for the Pilatus are:
      <ul>
        <li>Internal (external signal not used)</li>
        <li>External Enable (count while external trigger line is high, readout on high to low transition)</li>
        <li>External Trigger (begin acquisition sequence on high to low transition of external trigger line)</li>
        <li>Multiple External Trigger (high to low transition on external signal triggers a single acquisition 
            for the programmed exposure time)</li>
        <li>Alignment (collect images as fast as exposure time and readout permit, images written to a temporary file)</li>
      </ul>
      The first 4 modes correspond directly to the camserver commands <code>Exposure</code>,
      <code>ExtEnable</code>, <code>ExtTrigger</code>, and <code>ExtMTrigger</code> respectively.  
      Alignment mode uses the <code>Exposure</code> command as well, but continuously takes images into
      the same temporary file (<code>alignment.tif</code>).
    </td>
  </tr>
  <tr>
    <td>ADExposureTime</td>
    <td>$(P$(R)ExposureTime</td>
    <td>In External Enable mode this value is not
      used by camserver.  However, it should be set larger than the maximum time exposure time from the 
      external source, so that pilatusROI.st can estimate how long 
      to wait for the data files to be created before timing out.</td>
  </tr>
    <td>ADNumImages</td>
    <td>$(P$(R)NumImages</td>
    <td>Controls the number of images to acquire.  It applies in all trigger modes except
        Alignment.</td>
  </tr>
    <td>ADExposurePeriod</td>
    <td>$(P$(R)ExposurePeriod</td>
    <td>Controls the exposure period in seconds.  It is only in Internal or External Trigger modes
      when NumImages &gt 1.</td>
  </tr>
  <tr>
    <td>ADNumExposures</td>
    <td>$(P$(R)NumExposures</td>
    <td>Controls the number of exposures per image.  It is only used in External Enable mode.</td>
  </tr>
  <tr>
    <td>ADAquire</td>
    <td>$(P$(R)Acquire</td>
    <td>Controls the acquisition. Setting this to 1 starts image acquisition.
      The driver sets the record to 0 when acquisition is complete.  This means an entire
      acquisition series if NImages &gt 1. Setting this to 0 aborts an acquisition. If the driver
      was currently acquiring imges then this record will cause the "Stop" and "K" (Kill) commands to
      be sent to camserver.</td>
  </tr>
  <tr>
    <td>ADFilePath</td>
    <td>$(P$(R)FilePath</td>
    <td>Controls the path for saving images.  It must be a valid path for camserver 
      <i>and</i> for the areaDetector driver, which is normally running in an EPICS IOC.  
      If camserver and the EPICS IOC are not running on the same machine then soft links
      will typically be used to make the paths look identical.</td>
  </tr>
    <td>ADFileFormat</td>
    <td>$(P)$(R)FileFormat</td>
    <td>camserver uses the file extension to determine what format to save the files in.  The areaDetector Pilatus
      driver only supports TIFF files, so the extension should be .tif.
      When saving multiple images (NImages>1) camserver has its own rules for creating the
      names of the individual files.  The rules are as follows.
      The name constructed using the algorithm described for ADFileTemplate in
      <a href="areaDetectorDoc.html">areaDetectorDoc.html</a>
      is used as a basename. 
      The following examples show the interpretation of the basename.
      <pre>
      Basename            Files produced
     
      test6.tif           test6_00000.tif,  test6_00001.tif, ...
      test6_.tif          test6_00000.tif,  test6_00001.tif, ...
      test6_000.tif       test6_000.tif,    test6_001.tif, ...
      test6_014.tif       test6_014.tif,    test6_015.tif, ...
      test6_0008.tif      test6_0008.tif,   test6_0009.tif, ...
      test6_2_0035.tif    test6_2_0035.tif, test6_2_0036.tif, ...
      </pre>

      The numbers following the last '_' are taken as a format template,
      and as a start value.  The minimum format is 3; there is no maximum; the
      default is 5.  The format is also constrained by the requested number of images.</td>
  </tr>    

</tbody>
</table>

<center><h2 id="Driver_parameters">
                Pilatus specific parameters</h2></center>
<p>
The Pilatus driver implements the following parameters in addition to those in ADStdDriverParams.h:
</p>
<table style="text-align: left" cellspacing="2" cellpadding="2" border="1">
  <tbody>
  <tr>
    <td colspan="7", align="center"><b>Parameter Definitions in pilatusDetector.cpp and EPICS Record Definitions in pilatus.template</b></td>
  </tr>
  <tr>
    <th>Enum name</th>
    <th>asyn interface</th>
    <th>Access</th>
    <th>Description</th>
    <th>drvUser string</th>
    <th>EPICS record name</th>
    <th>EPICS record type</th>
  </tr>
  <tr>
    <td>PilatusDelayTime</td>
    <td>asynFloat64</td>
    <td>r/w</td>
    <td>Delay in seconds between the external trigger 
        and the start of image acquisition.  It only applies in External Trigger mode</td>
    <td>DELAY_TIME</td>
    <td>$(P)$(R)DelayTime</td>
    <td>ao</td>
  </tr>
  <tr>
    <td>PilatusThreshold</td>
    <td>asynFloat64</td>
    <td>r/w</td>
    <td>Threshold energy in keV</td>
    <td>THRESHOLD</td>
    <td>$(P)$(R)ThresholdEnergy</td>
    <td>ao</td>
  </tr>
  <tr>
    <td>N/A</td>
    <td>N/A</td>
    <td>r/w</td>
    <td>Gain menu. Controls the value of Vrf, which determines the shaping time and gain of the
        input amplifiers.  The allowed values are:
        <ul>
          <li>0 ("Fast/Low")  Fastest shaping time (~125ns) and lowest gain. </li>
          <li>1 ("Medium/Medium") Medium shaping time (~200 ns) and medium gain. </li>
          <li>2 ("Slow/High") Slow shaping time (~400 ns) and high gain. </li>
          <li>3 ("Slow/Ultrahigh") Slowest peaking time (? ns) and highest gain. </li>
        </ul></td>
    <td>N/A</td>
    <td>$(P)$(R)GainMenu</td>
    <td>mbbo</td>
  </tr>
  <tr>
    <td>PilatusArmed</td>
    <td>asynInt32</td>
    <td>r/o</td>
    <td>Flag to indicate when the Pilatus is ready to accept external trigger signals (0=not ready, 1=ready).
        This should be used by clients to indicate when it is OK to start sending trigger pulses
        to the Pilatus.  If pulses are send before Armed=1 then the Pilatus may miss them, leading to
        DMA timeout errors from camserver</td>
    <td>ARMED</td>
    <td>$(P)$(R)Armed</td>
    <td>bi</td>
  </tr>
  <tr>
    <td>PilatusTiffTimeout</td>
    <td>asynFloat64</td>
    <td>r/w</td>
    <td>Timeout in seconds when reading a TIFF file</td>
    <td>TIFF_TIMEOUT</td>
    <td>$(P)$(R)ReadTiffTimeout</td>
    <td>ao</td>
  </tr>
  <tr>
    <td>PilatusBadPixelFile</td>
    <td>asynOctet</td>
    <td>r/w</td>
    <td>Name of a file to be used to replace bad pixels.
      If this record does not point to a valid bad pixel file then no bad pixel mapping is performed.  
      The bad pixel map
      is used before making the NDArray callbacks.  It does not modify
      the data in the files that camserver writes.  This is a simple ASCII file with the following
      format:
      <pre>
      badX1,badY1 replacementX1,replacementY1 
      badX2,badY2 replacementX2,replacementY2
      ...
      </pre>
      The X and Y coordinates range from 0 to NXPixels-1 and NYPixels-1. Up to 100 bad pixels can be defined.
      The bad pixel mapping simply replaces the bad pixels with another pixel's value.
      It does not do any averaging.  It is felt that this is sufficient for the purpose for which 
      pilatusROI was written, namely fast on-line viewing of ROIs and ImageData.  More sophisticated
      algorithms can be used for offline analysis of the image files themselves.
      The following is an example bad pixel file for a GSECARS detector:
      <pre>
          263,3   262,3
          264,3   266,3
          263,3   266,3
          300,85  299,85
          300,86  299,86
          471,129 472,129
      </pre></td>
    <td>BAD_PIXEL_FILE</td>
    <td>$(P)$(R)BadPixelFile</td>
    <td>waveform</td>
  </tr>
  <tr>
    <td>PilatusNumBadPixels</td>
    <td>asynInt32</td>
    <td>r/o</td>
    <td>The number of bad pixels defined in the bad pixel file.  
        Useful for seeing if the bad pixel file was read correctly.</td>
    <td>NUM_BAD_PIXELS</td>
    <td>$(P)$(R)NumBadPixels</td>
    <td>longin</td>
  </tr>
  <tr>
    <td>PilatusFlatFieldFile</td>
    <td>asynOctet</td>
    <td>r/w</td>
    <td>Name of a file to be used to correct for the flat field.  
        If this record does not point to a valid flat field file then no flat field correction is performed.  
        The flat field file is simply a TIFF file collected by the Pilatus that is used to correct for
        spatial non-uniformity in the response of the detector.  It should be collected with a spatially uniform
        intensity on the detector at roughly the same energy as the measurements being corrected.
        When the flat field file is read, the average pixel value (averageFlatField) is computed
        using all pixels with intensities > PilatusMinFlatField.  All pixels with intensity < PilatusMinFlatField
        in the flat field are replaced with averageFlatField.  
        When images are collected before the NDArray callbacks are performed
        the following per-pixel correction is applied:
        <pre>
            ImageData[i] = (averageFlatField * ImageData[i])/flatField[i];
        </pre></td>
    <td>FLAT_FIELD_FILE</td>
    <td>$(P)$(R)FlatFieldFile</td>
    <td>waveform</td>
  </tr>
  <tr>
    <td>PilatusMinFlatField</td>
    <td>asynInt32</td>
    <td>r/w</td>
    <td>The mimimum valid intensity in the flat field.  This value must be set > 0 to prevent divide by 0 errors.  
        If the flat field was collected with some pixels having very low intensity then this value can be used to
        replace those pixels with the average response.</td>
    <td>MIN_FLAT_FIELD</td>
    <td>$(P)$(R)MinFlatField</td>
    <td>longout</td>
  </tr>
  <tr>
    <td>PilatusFlatFieldValid</td>
    <td>asynInt32</td>
    <td>r/o</td>
    <td>This record indicates if a valid flat field file has been read. 0=No, 1=Yes.</td>
    <td>FLAT_FIELD_VALID</td>
    <td>$(P)$(R)FlatFieldValid</td>
    <td>bi</td>
  </tr>
  <tr>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>asyn record to control debugging communication with camserver</td>
    <td>N/A</td>
    <td>$(P)$(R)CamserverAsyn</td>
    <td>asyn</td>
  </tr>
</tbody>
</table>







  <li><code>FullFilename</code> (waveform, FTVL=UCHAR, NELM=256)<br/>
      This is a read-only record that contains the full filename of the current file, after the above
      code has been executed.  Note that the FullFilename is not constructed until Acquire is set to 1.
</ul>
<h3 id="ROI related records">
             ROI related records</h3>
The SNL code supports up to 32 rectangular ROIs.  Fewer ROIs can be used by loading the pilatusROI_N.template file
fewer than 32 times, and passing NROIS<32 to the SNL program when it is started.  In the following
record names $(N) is a number from 1 to 32.  ROIs can be any size from a single pixel to the entire
chip. 
An ROI is considered invalid and ignorred by the SNL program if any of Xmin, Xmax, YMin, YMax is less than 0 or
greater than the size of the chip in that direction.  The ROI is also invalid if Xmin>XMax or YMin>YMax.  
<ul>
  <li>ROI$(N)XMin</code> (longout)<br/>
      The minimum value of X for ROI N.</li>
  <li><code>ROI$(N)XMax</code> (longout)<br/>
      The maximum value of X for ROI N.</li>
  <li><code>ROI$(N)YMin</code> (longout)<br/>
      The minimum value of Y for ROI N. </li>
  <li><code>ROI$(N)YMax</code> (longout)<br/>
      The maximum value of Y for ROI N.</li>
  <li><code>ROI$(N)BgdWidth</code> (longout)<br/>
      The background width ROI N.  ROI$(N)BgdWidth<=0 means no background subtraction is done, and
      ROI$(N)NetCounts=ROI$(N)TotalCounts.  The background region is defined as follows:
   <ul>
     <li>If ROI$(N)BgdWidth=1 then the background is one pixel outside of the perimeter of the ROI, 
         i.e the single-pixel wide
         rectangular box defined by ROI$(N)XMin-1, ROI$(N)XMax+1, ROI$(N)YMin-1, and ROI$(N)YMax+1.
         However, if any of those locations would be outside of the chip then that dimension is changed
         to be on the perimeter of the ROI. This ensures that
         a valid background region can be defined even if the ROI touches the edge of the detector.</li>
     <li>If ROI$(N)BgdWidth>1 then the background is a rectangular box of width ROI$(N)BgdWidth, moving
         out from the ROI location defined above.  However, if the background would go
         beyond the edge of the detector, then it is clipped to the largest valid width in
         that direction.</li>
    </ul>
  </li>
  <li><code>ROI$(N)TotalCounts</code> (ao)<br/>
      The total counts in ROI N.</li>
  <li><code>ROI$(N)NetCounts</code> (ao)<br/>
      The net counts in ROI N, i.e. the total counts minus the background counts.  This is determined
      by computing the average number of counts per pixel in the background, and subtracting this from
      the counts in the ROI.</li>
  <li><code>ROI$(N)MinCounts</code> (longout)<br/>
      The minimum counts in any pixel in ROI N.</li>
  <li><code>ROI$(N)MaxCounts</code> (longout)<br/>
      The maximum counts in any pixel in ROI N.  This can be useful to monitor to make sure that the 20-bit
      limit of 1,048,575 is not being approached.</li>
  <li><code>ROI$(N)Label</code> (stringout)<br/>
      The string label for ROI N.</li>
  <li><code>ROI$(N)WFTotalCounts</code> (waveform, FTVL=DOUBLE, NELM=$(NCHANS))<br/>
      The total counts in ROI N in a waveform record.  Valid when NImages>1.</li>
  <li><code>ROI$(N)WFNetCounts</code> (waveform, FTVL=DOUBLE, NELM=$(NCHANS))<br/>
      The net counts in ROI N in a waveform record. Valid when NImages>1.</li>
  <li><code>MinWFUpdateTime</code> (ao)<br/>
      This record controls the minimum time between posting the ROI$(N)WFTotalCounts and ROI$(N)WFNetCounts
      arrays to EPICS.  
      This should normally be set to a value >0.1 second to reduce the network bandwidth use. The SNL
      program always posts the arrays when acquisition completes, so that the final ROI data for the 
      series is sent to EPICS.</li>
</ul>
The ROI$(N)TotalCounts and ROI$(N)NetCounts are computed as each TIFF file is read, regardless of the
value of NImages.  The ROI$(N)WFTotalCounts and ROI$(N)WFNetCounts arrays are computed and posted to 
EPICS when acquiring data with NImages>1.  The first element in each array is the for the first image
in the series, etc.

<h3 id="Image related records">
             Image related records</h3>
<ul>
  <li><code>ImageData</code> (waveform, FTVL=LONG, NELM=$(NPIXELS))<br/>
      The detector image data as an EPICS waveform record. In order for EPICS clients
      to receive this data they must be built with EPICS R3.14 (not R3.13), and the environment variable
      EPICS_CA_MAX_ARRAY_BYTES on both the EPICS IOC computer and EPICS client computer must be set to a value 
      at least as large as the image size in bytes, i.e. to 379860 or more.
  <li><code>NXPixels</code> (longout)<br/>
      The number of pixels in the X direction on the detector. The SNL program needs to know this value.
      EPICS clients can use this value to reformat ImageData from
      a 1-D array to a 2-D array.
  <li><code>NYPixels</code> (longout)<br/>
      The number of pixels in the Y direction on the detector.  The SNL program needs to know this value.
      EPICS clients can use this value to reformat ImageData from
      a 1-D array to a 2-D array.
  <li><code>HighlightROIs</code> (bo)<br/>
      This record controls the whether the SNL program highlights the ROI borders in the image before
      sending the images to EPICS.  If selected then the pixels on the ROI borders are replaced with the
      value of the most intense pixel in the image, so they will always be visible in the display.  
      0=No, don't highlight, 1=Yes, highlight.
  <li><code>PostImages</code> (bo)<br/>
      This record controls the whether the SNL program sends ImageData to EPICS.  
      0=No, don't send, 1=Yes, send.  This can be set to 0 to reduce the network bandwidth use.
  <li><code>MinImageUpdateTime</code> (ao)<br/>
      This record controls the minimum time between posting ImageData to EPICS.  
      This should normally be set to a value >0.5 second to reduce the network bandwidth use. This
      means that not all images may be sent to EPICS.  This value is ignorred when AcquireMode=Alignment.
</ul>

  <li><code>FlatFieldValid</code> (bo)<br/>
      This record indicates if a valid flat field file has been read. 0=No, 1=Yes.
</ul>

<h3 id="Communication related records">
             Communication related records</h3>
<ul>
  <li><code>ReadTiffTimeout</code> (ao)<br/>
      This record controls the timeout in seconds between when the SNL program thinks a TIFF file should be ready
      to read, and when a timeout will occur.  It should be set to several seconds, because there can be delays
      for various reasons.  One reason is that there is sometimes a delay between when an External Enable
      acquisition is started and when the first external pulse occurs.  Another is that it can take some time for
      camserver processes to finish writing the files.
  <li><code>SendMessage</code> (waveform, FTVL=UCHAR, NELM=256)<br/>
      This read-only record contains the most recent message sent from the SNL program to camserver.  
  <li><code>ReplyMessage</code> (waveform, FTVL=UCHAR, NELM=256)<br/>
      This read-only record contains the most recent reply message from camserver to the SNL program.  
  <li><code>Connect</code> (bo)<br/>
      Processing this record causes the drvAsynIPPort server to connect to camserver.  
      This normally happens once in the
      startup script, and does not need to be processed again unless Disconnect is processed.  
<li><code>Disconnect</code> (bo)<br/>
      Processing this record causes the drvAsynIPPort server to disconnect from camserver.  
      This can be used to allow another
      program, such as TVX, to temporarily take control of camserver, without restarting the EPICS IOC.  Use
      the Connect record to reconnect the IOC to camserver.
</ul>

<h3 id="Scan related records">
             Scan related records</h3>
<ul>
  <li><code>scan1, scan2, scan3, scan4, scanH</code> (sscan)<br/>
      The example IOC startup script loads the scan.sb database from the SSCAN module.  This loads 5 sscan
      records which can be used to perform up to 4-dimensional scans with any EPICS PV as positioners and
      detectors.  The scan records are very useful with the Pilatus for scanning the ThresholdEnergy PV
      and plotting the counts in an ROI that includes the entire detector.  This allows setting the energy
      threshold to detect the x-rays of interest.
 
<p>&nbsp;</p>

<center><h2 id="EPICS startup script">
                     EPICS startup script</h2></center>
<p>
pilatusROI.template is loaded with the following macro parameters:
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <tr>
    <th>Macro parameter</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>$(DET)</code></td>
    <td>PV name prefix.  This identifies this Pilatus detector from others that may be
        running on the same subnet.
    </td>
  </tr>
  <tr>
    <td><code>$(NXPIXELS)</code></td>
    <td>The number of pixels in the X (fast index) direction on the detector. This is 487 for the Pilatus 100K.</td>
  </tr>
  <tr>
    <td><code>$(NYPIXELS)</code></td>
    <td>The number of pixels in the Y (slow index) direction on the detector.  This is 195 for the Pilatus 100K.</td>
  </tr>
  <tr>
    <td><code>$(NPIXELS)</code></td>
    <td>The total number of pixels on the detector.  This is NXPIXELS*NYPIXELS=94965 for the Pilatus 100K.</td>
  </tr>
  <tr>
    <td><code>$(PORT)</code></td>
    <td>The name of the asyn port connected to the Pilatus via a TCP/IP socket.</td>
  </tr>
</TBODY>
</TABLE>

<p>
pilatusROI_N.template is loaded for each ROI with the following macro parameters:
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <tr>
    <th>Macro parameter</th>
    <th>Description</th>
  <tr>
    <td><code>$(DET)</code></td>
    <td>PV name prefix.  This identifies this Pilatus detector from others that may be
        running on the same subnet.</td>
  </tr>
  <tr>
    <td><code>$(N)</code></td>
    <td>The number of this ROI. Starts with 1.</td>
  </tr>
  <tr>
    <td><code>$(XMIN)</code></td>
    <td>The minimum value of X for this ROI. Starts with 0.</td>
  </tr>
  <tr>
    <td><code>$(XMAX)</code></td>
    <td>The maximum value of X for this ROI. Starts with 0.</td>
  </tr>
  <tr>
    <td><code>$(YMIN)</code></td>
    <td>The minimum value of Y for this ROI. Starts with 0.</td>
  </tr>
  <tr>
    <td><code>$(YMAX)</code></td>
    <td>The maximum value of Y for this ROI. Starts with 0.</td>
  </tr>
  <tr>
    <td><code>$(BGD_WIDTH)</code></td>
    <td>The background width for this ROI.  
    If BGD_WIDTH <=0 then no background subtraction is done, and NetCounts=TotalCounts.</td>
  </tr>
  <tr>
    <td><code>$(NCHANS)</code></td>
    <td>The maximum number of elements in the WFTotalCounts and WFNetCounts waveform arrays.
        This sets the maximum value of NImages for collecting ROI arrays.</td>
  </tr>
</TBODY>
</TABLE>

<p>
The pilatusROIs SNL program is started with the following macro parameters:
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <tr>
    <th>Macro parameter</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>DET</code></td>
    <td>PV name prefix.  This identifies this Pilatus detector from others that may be
        running on the same subnet.</td>
  </tr>
  <tr>
    <td><code>PORT</code></td>
    <td>The name of the asyn port connected to the Pilatus via a TCP/IP socket.</td>
  </tr>
  <tr>
    <td><code>NROIS</code></td>
    <td>The number of ROIs loaded in the substitutions file with pilatusROI_N.template.
        Maximum=32.</td>
  </tr>
</TBODY>
</TABLE>

<p>
The following is an example st.cmd startup script:
<pre>
< envPaths

###
# Load the EPICS database file
dbLoadDatabase("$(PILATUS)/dbd/pilatus.dbd")
pilatus_registerRecordDeviceDriver(pdbbase)

###
# Create the asyn port to talk to the Pilatus on port 41234.
drvAsynIPPortConfigure("pilatus","gse-pilatus1:41234")
# Set the input and output terminators.
asynOctetSetInputEos("pilatus", 0, "\030")
asynOctetSetOutputEos("pilatus", 0, "\n")
# Define the environment variable pointing to stream protocol files.
epicsEnvSet("STREAM_PROTOCOL_PATH", "$(PILATUS)/pilatusApp/Db")

###
# Specify where save files should be
set_savefile_path(".", "autosave")

###
# Specify what save files should be restored.  Note these files must be
# in the directory specified in set_savefile_path(), or, if that function
# has not been called, from the directory current when iocInit is invoked
set_pass0_restoreFile("auto_settings.sav")
set_pass1_restoreFile("auto_settings.sav")

###
# Specify directories in which to to search for included request files
set_requestfile_path("./")
set_requestfile_path("$(AUTOSAVE)", "asApp/Db")
set_requestfile_path("$(CALC)",     "calcApp/Db")
set_requestfile_path("$(SSCAN)",    "sscanApp/Db")
set_requestfile_path("$(PILATUS)",  "pilatusApp/Db")

###
# Load the save/restore status PVs
dbLoadRecords("$(AUTOSAVE)/asApp/Db/save_restoreStatus.db", "P=PILATUS:")

###
# Load the substitutions for for this IOC
dbLoadTemplate("PILATUS_all.subs")
# Load an asyn record for debugging
dbLoadRecords("$(ASYN)/db/asynRecord.db", "P=PILATUS:,R=asyn1,PORT=pilatus,ADDR=0,IMAX=80,OMAX=80")

# Load sscan records for scanning
dbLoadRecords("$(SSCAN)/sscanApp/Db/scan.db", "P=PILATUS:,MAXPTS1=2000,MAXPTS2=200,MAXPTS3=20,MAXPTS4=10,MAXPTSH=2048")

###
# Set debugging flags if desired
#asynSetTraceIOMask("pilatus",0,2)
#asynSetTraceMask("pilatus",0,3)

###
# Start the IOC
iocInit

###
# Save settings every thirty seconds
create_monitor_set("auto_settings.req", 30, "P=PILATUS:")

###
# Start the SNL program
seq(pilatusROIs, "DET=PILATUS:, PORT=pilatus, NROIS=16")
</pre>

The following is the substutitions file PILATUS_all.subs referenced above. 
It creates 16 ROIS, and defines 5 valid ones: the entire chip, and the 4 quadrants of the chip:
<pre>
ffile $(PILATUS)/db/pilatusROI.template {
pattern 
{DET,       NXPIXELS,  NYPIXELS,  NPIXELS,   PORT}
{PILATUS:,       487,       195,    94965,   pilatus}
}

file $(PILATUS)/db/pilatusROI_N.template {
pattern 
{DET,       N,  XMIN,   XMAX,  YMIN,  YMAX,  BGD_WIDTH,  NCHANS}
{PILATUS:,  1,     0,    486,     0,   194,          1,    2000}
{PILATUS:,  2,     0,    243,     0,    97,          1,    2000}
{PILATUS:,  3,     0,    243,    98,   194,          1,    2000}
{PILATUS:,  4,   244,    486,     0,    97,          1,    2000}
{PILATUS:,  5,   244,    486,    98,   194,          1,    2000}
{PILATUS:,  6,    -1,     -1,    -1,    -1,          1,    2000}
{PILATUS:,  7,    -1,     -1,    -1,    -1,          1,    2000}
{PILATUS:,  8,    -1,     -1,    -1,    -1,          1,    2000}
{PILATUS:,  9,    -1,     -1,    -1,    -1,          1,    2000}
{PILATUS:, 10,    -1,     -1,    -1,    -1,          1,    2000}
{PILATUS:, 11,    -1,     -1,    -1,    -1,          1,    2000}
{PILATUS:, 12,    -1,     -1,    -1,    -1,          1,    2000}
{PILATUS:, 13,    -1,     -1,    -1,    -1,          1,    2000}
{PILATUS:, 14,    -1,     -1,    -1,    -1,          1,    2000}
{PILATUS:, 15,    -1,     -1,    -1,    -1,          1,    2000}
{PILATUS:, 16,    -1,     -1,    -1,    -1,          1,    2000}
}
</pre>

<p>&nbsp;</p>

<center><h2 id="MEDM screens">
                     MEDM screens</h2></center>
<p>
The following show the MEDM screens that are used to control the pilatusROI software.</p>

<p>&nbsp;</p>

<code>pilatusROI.adl</code> is the main screen used to control the pilatusROI SNL
program. All records except those that are specific to each ROI are accessed through this
screen.  
<center><h3>pilatusROI.adl</h3>
<img src="pilatusROI.png"></center>

<p>&nbsp;</p>

<code>pilatus8ROIs.adl</code> is used to define the ROIs, and to display the statistics for
each ROI.  In this example there are 2 valid ROIs defined.  ROI 1 is a small rectangle near the center
containing the Bragg diffraction peak from a crystal.  ROI 2 is the entire chip.
<center><h3>pilatus8ROIs.adl</h3>
<img src="pilatus8ROIs.png"></center>

<p>&nbsp;</p>

<code>pilatusROI_waveform.adl</code> is used to plot the net or total counts in an ROI when
NImages>1.  In this example the plot is the net counts in ROI 1 as the diffractometer chi was scanned
+- 1 degree with 1000 points at .02 seconds/point.  This was done with the SPEC command
<pre>
lup chi -1 1 1000 .02
</pre>
using trajectory scanning on a Newport kappa diffractometer.  This was a compound motor scan with the
Newport XPS putting out pulses every .02 seconds.  These pulses triggered the Pilatus in External Enable mode.
The pilatusROI program read each TIFF file as it was created and updated this plot every 0.2 seconds.
The total time to collect this scan with 1000 images was 20 seconds.
<center><h3>pilatusROI_waveform.adl</h3>
<img src="pilatusROI_waveform.png"></center>

<p>&nbsp;</p>

<code>scan_more.adl</code> is used to define a scan.  In this example the sscan record is set up
to scan the ThresholdEnergy PV and to collect the total counts in ROI2, which was defined to include
the entire detector.
<center><h3>scan_more.adl</h3>
<img src="pilatusROI_scan_more.png" alt="pilatusROI_scan_more.png"></center>

<p>&nbsp;</p>

<code>scanDetPlot.adl</code> is used to plot the results of a scan after it is complete.  
In this example the total counts in ROI 2 are plotted as a function of the ThresholdEnergy as it was
scanned from 3000 to 10000 eV in 250 eV steps.  The source was Fe55, and the cut-off is at 6 keV, as
expected for the Mn Ka and Mn Kb x-rays that this source produces.
<center><h3>scanDetPlot.adl</h3>
<img src="pilatusROI_scan_plot.png" alt="pilatusROI_scan_plot.png"></center>


<p>&nbsp;</p>

<code>asynRecord.adl</code> is used to control the debugging information printed by the asyn TCP/IP driver
(asynTraceIODriver) and the SNL program (asynTraceIODevice).
<center><h3>asynRecord.adl</h3>
<img src="pilatusAsynRecord.png" alt="pilatusAsynRecord.png"></center>

<p>&nbsp;</p>

<code>asynOctet.adl</code> can be used to send any command to camserver and display the response.  It can
be loaded from the More menu in asynRecord.adl above.
<center><h3>asynOctet.adl</h3>
<img src="pilatusAsynOctet.png" alt="pilatusAsynOctet.png/></center>

<p>&nbsp;</p>

<center><h2 id="IDL Image Display Client">
                     IDL Image Display Client</h2></center>

There is an IDL program called <code>epics_image_display</code> 
that can be used to display the ImageData PV that pilatusROI sends over EPICS.  This IDL
client is available as source code (which requires an IDL license), and also as a pre-built IDL .sav 
file that can be run for free under the IDL Virtual Machine.  This IDL program can run on any machine that IDL
runs on, and that has the ezcaIDL shareable library built for it.  This includes Windows, Linux, Solaris, and Mac.
<code>epics_image_display</code> is included in the 
<a href="http://cars.uchicago.edu/software/IDL/imaging.html">CARS IDL imaging software.</a>

<p>
The control window for <code>epics_image_display</code> is shown below.  It has fields to input the name of
the EPICS PV with the image data, which is $(DET)ImageData in the case of pilatusROI.  It also has fields
for the number of pixels in the X and Y directions.  This is needed because EPICS waveform records are
1-dimensional only, and so do not contain the information on the number of rows and columns in the image.

<center><h3>Main window for IDL epics_image_display</h3>
<img src="pilatusROI_EPICS_ImageDisplay.png" alt="pilatusROI_EPICS_ImageDisplay.png"></center>

<p>&nbsp;</p>

<code>epics_image_display</code> uses the routine 
<a href="http://cars.uchicago.edu/software/IDL/imaging_routines.html#IMAGE_DISPLAY">image_display.pro</a>
to display the images.  This routine displays row and column profiles as the cursor is moved.  It allows
changing the color lookup tables, and zooming in and out with the left and right mouse buttons.  The following
is an example of <code>image_display</code> displaying a Pilatus image with an Fe55 source in front of the detector.

<center><h3>IDL image_display with Fe55 radioactive source</h3>
<img src="pilatusROI_IDL_ImageDisplay.png"></center>

<p>&nbsp;</p>

<center><h2 id="SPEC interface">
                     SPEC interface</h2></center>

At the GSECARS beamlines (13-ID-C and 13-BM-C) at the APS we use SPEC to control our Newport diffractometers.
We have added and modified SPEC macros to use pilatusROI to treat the Pilatus detector as a SPEC
counter.  This works in both traditional step-scanning mode, as well as in 
<a href="http://cars.uchicago.edu/software/epics/trajectoryScan.html">trajectory scanning</a> mode.
Here are some snippets from the SPEC macros for the Pilatus.  We can supply the source files on request.

<pre>
# need some more globals (kludge)
global    PILATUS_ROI_PV    
global    PILATUS_imgPATH_PV
global    PILATUS_FNAME_PV
global    PILATUS_FILENUMBER_PV
global    PILATUS_FILEFORMAT_PV
global    PILATUS_EXPSRTM_PV
global    PILATUS_NFRAME_PV
global    PILATUS_EXPPRD_PV
global    PILATUS_NEXPFRM_PV
global    PILATUS_ACQ_PV
global    PILATUS_ACQMODE_PV

###############################################################
def _setup_img '{
     local j, str
		
     # PILATUS_PREFIX should be detector aquisition pv (GSE-PILATUS1:)
     if ( PILATUS_PREFIX == "") PILATUS_PREFIX = "GSE-PILATUS1:"
     PILATUS_PREFIX = getval("Enter PILATUS pv prefix",PILATUS_PREFIX)

     # rois pvs
     PILATUS_ROI_PV    = PILATUS_PREFIX "ROI1NetCounts"
     PILATUS_imgPATH_PV = PILATUS_PREFIX "FilePath"
     PILATUS_FNAME_PV   = PILATUS_PREFIX "Filename"
     PILATUS_FILENUMBER_PV   = PILATUS_PREFIX "FileNumber"
     PILATUS_FILEFORMAT_PV = PILATUS_PREFIX "FileFormat"
     PILATUS_EXPSRTM_PV = PILATUS_PREFIX "ExposureTime"
     PILATUS_NFRAME_PV  = PILATUS_PREFIX "NImages"
     PILATUS_EXPPRD_PV  = PILATUS_PREFIX "ExposurePeriod"
     PILATUS_NEXPFRM_PV = PILATUS_PREFIX "NExposures"
     PILATUS_ACQ_PV     = PILATUS_PREFIX "Acquire"
     PILATUS_ACQMODE_PV = PILATUS_PREFIX "AcquireMode"
...

def epics_pilatus_count '{
...
     # write to data base fields
     # Need to convert path from string to byte array
     # Note: we use the "wait" parameter in epics_put here (new to spec5.7.02) so that
     # it uses ca_put_callback, to know that all PVs have been processed
     # before we start counting.  Use 1 second timeout, will actually be
     # much faster than this unless something is wrong.
     array _temp[256]
     _temp = PILATUS_IMAGE_DIR
     # Do not change path for now
     #epics_put(PILATUS_imgPATH_PV,_temp, 1)
     epics_put(PILATUS_FNAME_PV,img_fname, 1)
     epics_put(PILATUS_FILENUMBER_PV,NPTS, 1)
     epics_put(PILATUS_FILEFORMAT_PV,_fileformat, 1)
     epics_put(sc_prtm_pv,cnt_time_val, 1)
     epics_put(PILATUS_EXPSRTM_PV,cnt_time_val, 1)
     epics_put(PILATUS_ACQMODE_PV,0, 1)  # Internal trigger 
     epics_put(PILATUS_NFRAME_PV, 1, 1)
     epics_put(PILATUS_NEXPFRM_PV, 1, 1)


def user_getcounts '{
    local pv_roi, j, pv

...
   # using image_count routine  
    } else if ( EPICS_COUNT == 4 ) {
        S[iroi] = 0
        S[iroi] = epics_get(PILATUS_ROI_PV)
</pre>
  
<p>&nbsp;</p>

<center><h2 id="Performance measurements">
                     Performance measurements</h2></center>

The following measurements were done to demonstrate the performance that can be obtained with pilatusROI.
<OL>
  <li>AcquireMode=Internal, NImages=1000, ExposureTime=.005, ExposurePeriod=.01, NExposures=1.  
      The time to collect this series should be exactly 10.0 seconds.  
      The actual time was measured using the EPICS camonitor program. It printed the time when 
      acquisition was started (Acquire changed to Busy) and when acquisition was complete (Acquire changed to Done).
      The time was 10.274 seconds.  This includes the time for camserver to save all 1000 images to disk (366 MB), 
      and for pilatusROI to read each file, correct the bad pixels and flat field, compute the ROIs, and post the ROIs
      to EPICS.  It also posted the images to EPICS at 1Hz (10 images total).  The total additional time was less
      than 0.3 seconds for all 1000 images.
  <li>AcquireMode=Internal, NImages=1, ExposureTime=.01, NExposures=1.  
      An EPICS sscan record was used to collect 1000 points.  
      There were no positioner PVs (to eliminate motor overhead).  
      The only detector trigger was the pilatusROI Acquire PV.  The only detector PV was ROI1TotalCounts.
      In this mode camserver is being told to individually collect each file. 
      If there were no overhead then time to collect this series should be exactly 10.0 seconds.  
      The actual time measured using the EPICS camonitor program was 49.161 seconds.  
      The overhead is thus 39.161 seconds, or 39 ms per point.  
      In this single-frame mode pilatusROI is thus able to collect >20 images/second.
      For comparison, another measurement was done using the same EPICS sscan record, 
      but using a Joerger VSC16 scaler as the detector
      trigger and detector.  The preset time was also .01 seconds.  The elapsed time for a 1000 point scan was
      16.068 seconds, so the overhead was 6.068 seconds, or 6 ms per point.
  <li>AcquireMode=Ext. Enable, NImages=1000, NExposures=1.  
      SPEC was used to collect 1000 points using
      <a href="http://cars.uchicago.edu/software/epics/trajectoryScan.html">trajectory scanning</a> mode
      with the Newport XPS motor controller.  The following SPEC command was used:
      <pre>
      lup chi -2 2 1000 .015
      </pre>
      This tells SPEC to do a relative scan of the chi axis from -2 degrees to +2 degrees with 1000 points 
      at .015 seconds/point.  On our kappa diffractometer this entails a coordinated motion of the phi, kappa
      and omega axes.  The EPICS trajectory scanning software downloads the non-linear trajectory that SPEC computes
      into the XPS controller, which executes it.  As the motors are moving the XPS outputs synchronization pulses
      at the period of the collection time, .015 seconds in this case.  These pulses are stretched
      (see <a href="#Hardware notes">Hardware notes</a> below) and used as the external input to the Pilatus.
      The time to execute this scan should be 15.0 seconds.  The actual time was 16.3 seconds, measured
      using camonitor on the Acquire PV.  Again, this includes the time for camserver to save all 1000 images to disk 
      (366 MB), and for pilatusROI to read each file, correct the bad pixels and flat field, compute the ROIs, and post the ROIs
      to EPICS.  It also posted the images to EPICS at 1Hz (15 images total).  The total additional time was less
      than 1.3 seconds for all 1000 images.  As soon as the acquisition was complete SPEC plotted the net counts in
      the first ROI (containing the Bragg peak) as follows:
      <center><h3>1000 point SPEC scan with 15 ms per point collected in 16.3 seconds</h3>
      <img src="pilatusROI_spec.png"></center>
      <p>
      For comparison this identical scan was executed in traditional step-scanning mode, where the motors stopped
      at each point in the scan.  The Pilatus was run in Internal mode with NImages=1.  The total time for the scan
      was 870 seconds (more than 14 minutes), compared to 16.3 seconds in trajectory mode.  Most of this overhead
      is the settling time for the motors, with only a small fraction due to the Pilatus single-exposure mode. The
      trajectory scanning mode is thus more than 50 times faster to execute the identical SPEC scan.
</OL>

<p>&nbsp;</p>

<center><h2 id="Hardware notes">
                     Hardware notes</h2></center>
 
<h3>Trigger pulses</h3>
The Pilatus supports 3 types of external triggering.  In External Trigger mode (the camserver ExtTrigger command)
the Pilatus uses the programmed values of ExposureTime, ExposurePeriod, NImages and NExposures.  It waits for
a single external trigger, then waits for Delay seconds and then collects the entire sequence.  It is very similar
to Internal mode with NImages>1, except that it waits for a trigger to begin collecting the sequence.  

<p>In External Enable mode (the camserver ExtEnable command) the Pilatus uses the external signal to control acquisition.  
Only NImages and NExposures are used, ExposureTime and ExposurePeriod are not used.  When the signal
is high the detector counts, and on the transition to low it begins its readout.  

<p>In External MultiTrigger Mode (the camserver ExtMTrigger command) the Pilatus uses the programmed ExposureTime, 
in addition to NImages and NExposures.  Each external trigger pulse causes the Pilatus to collect one image
at the programmed exposure time.  This mode works well with a trigger source like the Newport motor controllers
or the SIS380x multichannel scaler,
that put out a short trigger pulse for each image.  One only needs to take care that the time between external trigger
pulses is at least 4msec longer than the programmed exposure time, to allow time for the detector to read out before
the next trigger pulse arrives.

<p>When using the External Enable mode, we use an inexpensive analog pulse generator
to convert the trigger pulses from the MM4005 and XPS to a form suitable for External Enable mode 
with the Pilatus.  This is the solution we have developed that seems to be reliable:
<ul>
  <li>The synchonization pulses from the Newport MM4005 or XPS controller are input into the external next pulse
      (channel advance, control signal 1) input of the SIS3801 multiscaler.  
      This is the normal configuration used for MCS counting
      without the Pilatus in trajectory scanning mode.
  <li>The Copy In Progress (CIP) output of the SIS3801 (control signal 5) is connected to the Trigger Input of a
      Tenma TGP110 10 MHz Pulse Generator.  CIP will output a pulse whenever the SIS3801 does a channel advance,
      either in external mode with the motor controller pulse input, or in internal timed channel advance mode.
      The TGP100 Pulse Generator is configured as follows:
      <ul>
        <li>Trigger Input connected to CIP output of SIS3801.
        <li>Triggered mode.
        <li>Complement output.
        <li>Pulse duration set with knobs to 3msec.
        <li>TTL Output connected to the External Input of the Pilatus.
      </ul>
  <li>With this configuration the SIS3801 CIP output is normally at 5V, and outputs a 0V pulse 1 microsecond long.  
      The trailing (rising) edge of that pulse triggers the TGP110.  The TGP110 TTL output is also normally at 5V,
      and outputs a 0V pulse 3 milliseconds long each time the SIS3801 pulses.  That output is connected to the
      Pilatus External Input.  In External Enable mode when Pilatus External Input is
      high the Pilatus is counting.  When the External Input is low the Pilatus reads out.  The readout time is
      set via the knobs on the pulse generator to be 3 ms, which is close to the minimum time allowed on the
      Pilatus.
</ul>
The Tenma TGP110 seems to be currently called a Tenma 72-6860, and lists for about $350 new 
at <a href="http://www.newark.com">Newark</a>.

<h3>Detector Voltage</h3>
When we were initially testing the Pilatus in the lab, we had many errors in External Enable mode, where it did
not seem to be seeing the external pulses.  camserver would get DMA timeouts, and need to be restarted.  Dectris 
said these were happening because the cables on our detector are longer than normal, and the voltage
drop from the power supply to the detector was leading to marginal voltage values.  They suggested shortening
the cables or increasing the supply voltage slightly.  When moving the detector to the hutch these
problems initially went away.  However, they then recurred, and we fixed the problem by increasing 
the power supply voltage from 4.4 to 4.7 volts at the detector.
<p>
Dectris has since informed me that they have increased the power supply voltage on all new Pilatus systems, 
so this should no longer be an issue.

     
<p>&nbsp;</p>

<center><h2 id="Restrictions">
                     Restrictions</h2></center>
The following are some current restrictions of the pilatusROI SNL program:
<ul>
  <li>Limited to TIFF file format.  
      camserver can save files in other formats, but pilatusROI can currently only read TIFF files. 
      Furthermore, it
      has a very simple TIFF reader.  It does not read the TIFF tags at all, but simply assumes that there
      is a 4096 byte header, followed by the 32-bit image data.  The size of the image data is controlled
      by the NXPixels and NYPixels PVs, which thus must be correctly set.
  <li>The EPICS IOC should be run on the same computer as camserver.
      This is not strictly necessary, and places a small additional load on the CPU and network 
      on that computer.  However, we have found that TIFF files are available to be read within 10ms after
      camserver says they have been written if the IOC is running on the same machine as camserver.  This is true
      even if the files are being saved on a remote NFS or SMB file system.  On the other hand, if the IOC and
      camserver are running on separate machines, then the filesystem can wait up to 1 second after camserver
      says the TIFF file has been written before the IOC can read it.  This is true even if the files are being
      written to the computer that the IOC is running on!  This 1 second delay is often unacceptable for fast 
      single-exposure scans, i.e. with NImages=1.
  <li>pilatusROI keeps retrying to read each TIFF file until
      the modification date of the TIFF file is <I>after</I> the time that the exposure command was issued.  
      If it did not
      do this check then it could be reading and displaying old files that happen to have the same name as the
      current files being collected.  This check requires that the computer that is running the soft IOC must
      have its clock well synchronized with the
      clock on the computer on which the files are being written 
      (i.e. the computer generating the file modification time).
      If the clocks are not synchronized then the files may appear to be stale when they are not,
      and pilatusROI will time out.  pilatusROI actually tolerates up to 10 second clock skew betweeen the computers
      but any more than this may lead to problems.
  <li>The Abort PV does not always work because camserver does not reliably implement the "K" command to stop
      an exposure sequence.  In particular with NImages>1 camserver seems to often ignore
      the K command completely, even with exposure times/periods as long as 10 seconds.
      With NImages=1 it does kill the exposure after a few seconds.
  <li>The following items are hardcoded in the SNL program.  They can be changed before compiling if necessary.
      Some could be changed to be EPICS PVs, so they could be controlled at run-time, but others must be defined
      at compile time because of limitations in the SNL semantics.
    <ul>
      <li>MAX_MESSAGE_SIZE=256  The maximum size of message to/from camserver.
      <li>MAX_FILENAME_LEN=256  The maximum size of a complete file name including path and extension.
      <li>FILE_READ_DELAY=.01 seconds.  The time between polling to see if the TIFF file exists
          or if it is the expected size.
      <li>MAX_BAD_PIXELS=100  The maximum number of bad pixels.
      <li>MAX_ROIS=32  The maximum number of ROIs
      <li>MAX_CHANS=2000 The maximum number of points in the ROI waveform arrays.
      <li>MAX_PIXELS=94965  The maximum number of pixels in the ImageData array.  Because of SNL semantics
          limitations this value must be defined at compile time, and cannot be changed at run time.
      <li>MAX_READ_ERRORS=3  The maximum number of TIFF file read errors before the SNL gives up and aborts
          acquisition.
    </ul>
</ul>

</body>
</html>
